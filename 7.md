As a Staff Engineer specializing in runtime systems, I frame **Method Dispatch** as the mechanism a system uses to bridge the gap between **abstraction** (a function name) and **hardware execution** (a memory address).

It is fundamentally a trade-off between **performance** (knowing the answer at compile time) and **flexibility** (deciding the answer at runtime).

Here is the precise, low-level breakdown of how dispatch works, specifically within the Swift ecosystem.

-----

### 1\. The Dispatch Hierarchy

| Type | Resolution Time | Mechanism | Performance | Flexibility |
| :--- | :--- | :--- | :--- | :--- |
| **Static (Direct)** | Compile Time | Hardcoded Address | Fastest (\~0-2ns) | None |
| **Table (Dynamic)** | Runtime | V-Table / Witness Table | Fast (\~5ns) | Polymorphism |
| **Message** | Runtime | String Selector Lookup | Slowest (\~15ns) | Runtime Swizzling |

-----

### 2\. Static Dispatch (Direct Dispatch)

**"The Compiler Knows All."**

When the compiler can determine exactly which function implementation to execute at compile time, it uses static dispatch.

#### Internal Mechanics

The compiler emits a `call` assembly instruction pointing directly to the memory address of the function.

  * **Assembly:** `call 0x100004f8` (Jump directly to the symbol).
  * **Optimization:** Because the function body is known, the compiler can perform **Inlining**—replacing the function call entirely with the code of the function itself. This reduces overhead to **zero**.

#### Usage in Swift

  * **Value Types:** `struct` and `enum` methods.
  * **Final Classes:** Methods marked `final`.
  * **Global Functions:** Methods defined outside types.
  * **Extensions:** Methods defined in extensions (standard, non-protocol extensions).

<!-- end list -->

```swift
struct Point {
    func draw() { print("Draw") } // Static Dispatch
}
```

-----

### 3\. Dynamic Dispatch (Table Dispatch)

**"The Pointer Chase."**

This is necessary for polymorphism (inheritance). If a variable is defined as a `Shape` but holds a `Circle`, the runtime must look up the correct `draw()` method.

#### Internal Mechanics: The V-Table

Swift classes use a **Virtual Method Table (vtable)**, similar to C++.

1.  **Object Layout:** Every class instance on the heap starts with a hidden pointer (the `isa` pointer).
2.  **Metadata:** The `isa` points to the Class Metadata.
3.  **The Table:** The metadata contains an array of function pointers (the vtable).
4.  **Execution:**
      * Load object -\> Read `isa` -\> Offset to function index (e.g., index 2) -\> Jump.

#### Internal Mechanics: The Witness Table (Protocols)

Protocols use a variation called a **Protocol Witness Table (PWT)**. Since structs don't share a common memory layout or vtable, Swift wraps them in an **Existential Container**.

  * **The Container:** Stores the value (buffer) + a pointer to the PWT.
  * **The PWT:** Maps the protocol's requirements to the specific struct's implementation.

#### Usage in Swift

  * **Classes:** Standard methods declared in the initial class body.
  * **Protocols:** Methods declared in the protocol definition.

<!-- end list -->

```swift
class Shape {
    func draw() {} // V-Table Dispatch
}
```

-----

### 4\. Message Dispatch

**"Ask, don't tell."**

This is the legacy of Objective-C/Smalltalk. Instead of looking up an offset, the runtime sends a named message.

#### Internal Mechanics: `objc_msgSend`

1.  The runtime calls `objc_msgSend(receiver, selector)`.
2.  It inspects the receiver's class **Method Cache** (a hash map).
3.  **Hit:** Jumps to implementation.
4.  **Miss:** Traverses the full method list and superclasses.
5.  **Failure:** Triggers "Method Forwarding" (allows dynamic interception).

#### Usage in Swift

  * Methods marked `@objc dynamic`.
  * Required for **KVO (Key-Value Observing)** and **Method Swizzling**.

-----

### 5\. The "Staff Engineer" Matrix (Swift Dispatch Rules)

This table explains 99% of "weird" Swift behavior interview questions.

| Entity Declared In | Struct / Enum | Class | Protocol | `@objc dynamic` |
| :--- | :--- | :--- | :--- | :--- |
| **Initial Declaration** | Static | Table (V-Table) | Table (Witness) | Message |
| **Extension** | Static | **Static** (Crucial) | Static | Message |

#### The "Extension Trap" Example

This is the most common pitfall. Methods in class extensions are **Statically Dispatched**. They cannot be overridden dynamically because they are not added to the vtable.

```swift
class Base {}

// Extension: Static Dispatch
extension Base {
    func greet() { print("Base") }
}

class Sub: Base {
    // ❌ This is NOT an override. It is a new function masking the old one.
    func greet() { print("Sub") }
}

let b: Base = Sub()
b.greet() 
// Output: "Base" 
// Why? Compiler sees 'b' is type Base. Extension methods are static. 
// It hardcodes the call to Base.greet().
```

-----

### 6\. Performance & Optimization

1.  **Throughput:** Static dispatch is roughly **5-10x faster** than dynamic dispatch in tight loops due to instruction pipelining and inlining.
2.  **Devirtualization:** The Swift compiler tries to "devirtualize" calls. If it can prove a class has no subclasses (e.g., inside a module with Whole Module Optimization), it converts Table Dispatch -\> Static Dispatch.
3.  **Advice:**
      * Default to `struct` (Static).
      * If you use classes, use `final` liberally (forces Static).
      * Only use `@objc dynamic` if you explicitly need runtime dynamism (KVO/Swizzling).

### Summary for the Interviewer

  * **Static Dispatch:** Compile-time resolution. Fastest. Used by Structs and Extensions.
  * **Table Dispatch:** Runtime vtable lookup. Used by standard Class methods.
  * **Message Dispatch:** Runtime string lookup. Slowest but most dynamic. Used by KVO/Objective-C.
  * **Key Insight:** Swift is unique because extensions use Static Dispatch, which breaks standard OOP polymorphism rules found in Java/C\#.

