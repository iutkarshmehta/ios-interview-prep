As a Staff Engineer, I frame **Method Dispatch** as the decision-making process the computer performs every time you call a function.

At its core, **Method Dispatch is the mechanism that maps a function name (like `draw()`) to a specific executable memory address (like `0x10F3B`).**

When you write code, you think in names and abstractions. The CPU, however, only understands memory addresses. Dispatch is the bridge between the two.

  * **The Simple Case:** If you have a specific function with no overrides, the compiler knows the address immediately. The map is a straight line.
  * **The Complex Case (Polymorphism):** If you have a variable typed as a generic `Shape`, but it holds a `Circle` at runtime, the system cannot simply "jump to Shape." It must figure out *which* version of `draw()` to run (the Circle's version). That decision process is Method Dispatch.

-----

Here is the deep, interview-ready breakdown of the three types of dispatch, how they work internally, and their specific behavior in Swift.

### 1\. Static Dispatch (Direct Dispatch)

**"The Compiler Knows All."**

This is the fastest form of dispatch. The decision of which function to run is made at **compile time**.

  * **How it works:** The compiler sees the function call, finds the exact memory address of the implementation, and hardcodes a `call` instruction to that address.
  * **Performance:** Extremely fast (1-2 nanoseconds). It also enables **Inlining**, where the compiler replaces the function call with the actual code of the function, reducing overhead to zero.
  * **Memory Layout:** No extra metadata is needed on the object.
  * **Swift usage:** `struct` methods, `enum` methods, `final class` methods, and methods in **extensions**.

**Example:**

```swift
struct Point {
    func draw() { print("Draw") }
}
let p = Point()
p.draw() 
// Compiler generates: call 0x1004F (Direct Address)
```

-----

### 2\. Dynamic Dispatch (Table Dispatch)

**"The Pointer Chase."**

This is the standard for Object-Oriented Programming. The decision is deferred until **runtime**.

  * **How it works:** The compiler doesn't know *which* implementation to run, so it generates code to look it up in a table.
  * **The V-Table (Classes):** Every class instance has a hidden pointer (often called `isa` or `vptr`) as its first 8 bytes. This points to a **Virtual Method Table (vtable)** shared by the class. The vtable is an array of function pointers.
    1.  Read the object's `isa` pointer.
    2.  Jump to the vtable.
    3.  Read the function pointer at a specific offset (e.g., index 2 for `draw`).
    4.  Jump to that function.
  * **The Witness Table (Protocols):** Since structs don't share inheritance, Swift uses a **Protocol Witness Table (PWT)**. When you cast a struct to a protocol (e.g., `any Drawable`), Swift wraps it in an "Existential Container" that holds the value *and* a pointer to the PWT.
  * **Performance:** Slower (\~5 nanoseconds) due to "pointer indirection" (chasing pointers prevents the CPU from pre-fetching instructions efficiently).
  * **Swift usage:** Standard `class` methods, `protocol` requirements.

**Example:**

```swift
class Shape { func draw() {} }
class Circle: Shape { override func draw() {} }

let s: Shape = Circle()
s.draw() 
// Runtime: Look up 's' -> Find VTable -> Find Index 0 -> Jump to Circle.draw
```

-----

### 3\. Message Dispatch

**"Ask, don't tell."**

This is the most dynamic and slowest form, used primarily by Objective-C and Swift's `@objc` features.

  * **How it works:** It does not use a fixed offset table. Instead, it sends a named message (a string selector) to the object.
  * **Internal Mechanism:** The runtime calls `objc_msgSend(object, selector)`.
    1.  It checks the object's **Method Cache** (a hash map) for the selector name.
    2.  If missed, it traverses the class's method list.
    3.  If missed, it walks up the superclass chain.
  * **Power:** Because the lookup is by *name*, not fixed offset, you can modify the lookup at runtime (Swizzling, KVO, ISA-swizzling).
  * **Performance:** Slowest (\~15+ nanoseconds), though heavily cached.
  * **Swift usage:** Methods marked `@objc dynamic`, Core Data, KVO.

-----

### The "Staff Engineer" Matrix: Swift Dispatch Rules

The most common interview "gotcha" in Swift is knowing *when* each dispatch is used. It depends on **Location** and **Type**.

| Declared Inside... | Struct / Enum | Class | Protocol | Extension |
| :--- | :--- | :--- | :--- | :--- |
| **Initial Definition** | Static | Table (V-Table) | Table (Witness) | **Static** |
| **`@objc dynamic`** | N/A | Message | Message | Message |

#### The Critical Pitfall: Extension Dispatch

Methods declared in a Swift **Extension** use **Static Dispatch** by default. This means they **cannot** be overridden by subclasses in the traditional polymorphic sense.

```swift
class Base {}

// Extensions use STATIC dispatch
extension Base {
    func greet() { print("Hello from Base") }
}

class Sub: Base {
    // This is NOT an override. It is a new function masking the old one.
    func greet() { print("Hello from Sub") }
}

let b: Base = Sub()
b.greet() 
// Output: "Hello from Base"
// Why? The compiler sees 'b' is a Base. The 'greet' in the extension is static.
// It hardcodes the call to Base.greet(), ignoring the subclass entirely.
```

### Summary

  * **Static:** "I know exactly where to go." (Fastest, Structs/Extensions).
  * **Dynamic (Table):** "I have a map (table) to find where to go." (Polymorphic, Classes/Protocols).
  * **Message:** "I will ask the object where to go." (Flexible, Objective-C/KVO).