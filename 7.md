As a Staff Engineer, here is the architectural breakdown of Method Dispatch, structured strictly into **What**, **Why**, and **How**.

-----

### **1. What is Method Dispatch?**

**Method Dispatch is the mechanism a system uses to map a function call (an abstraction) to a specific executable memory address (hardware instruction).**

When you write `object.draw()`, the CPU does not understand the name "draw." It only understands instruction pointers (e.g., `0x10F3B`). Method Dispatch is the decision-making process—happening either at compile time or runtime—that determines *which* set of instructions to execute for that specific call.

-----

### **2. Why do we need different types?**

We need multiple dispatch strategies to balance two competing engineering goals: **Performance** and **Polymorphism**.

  * **To achieve Peak Performance:** We want the compiler to hardcode the destination address. This eliminates lookup overhead and enables compiler optimizations like **Inlining** (copy-pasting the function body directly into the call site).
  * **To achieve Polymorphism (Dynamic Behavior):** We need the program to decide *at runtime* which function to call based on the data it holds (e.g., treating a `Circle` as a `Shape`). This requires a slower, more flexible lookup mechanism.
  * **To achieve Runtime Dynamism:** Sometimes we need to modify behavior while the app is running (e.g., Method Swizzling for analytics or KVO). This requires the most flexible, string-based lookup.

-----

### **3. How does it work internally?**

Dispatch is implemented in three primary ways, ranging from "Fast & Rigid" to "Slow & Flexible."

#### **A. Static Dispatch (Direct Dispatch)**

The compiler knows the function identity at build time.

  * **How it works:** The compiler generates a `call` assembly instruction pointing directly to the function's memory address (e.g., `call 0x1004F`).
  * **Internals:** No extra metadata is stored on the object. The CPU jumps straight to the code.
  * **Performance:** Fastest (1–2ns). Enables aggressive compiler optimizations (Inlining).
  * **Swift Usage:** `struct`, `enum`, `final class`, and methods in **Extensions**.

#### **B. Dynamic Dispatch (Table Dispatch)**

The compiler knows the *interface* but not the specific implementation. It relies on a table lookup at runtime.

  * **How it works:**
    1.  **V-Table (Classes):** Every class instance has a hidden pointer (the `isa` pointer) as its first word in memory. This points to the Class Metadata, which holds a **Virtual Method Table (vtable)**—an array of function pointers.
          * *Execution:* Load Object → Read `isa` → Go to V-Table → Read pointer at index X → Jump.
    2.  **Witness Table (Protocols):** Since structs don't inherit, Swift wraps them in an **Existential Container**. This container holds the value *and* a pointer to a **Protocol Witness Table (PWT)** specific to that type.
  * **Performance:** Moderate (\~5ns). The "pointer chase" (indirection) prevents some CPU pipelining and blocks inlining.
  * **Swift Usage:** Standard `class` methods and `protocol` requirements.

#### **C. Message Dispatch**

The runtime asks the object if it responds to a named message.

  * **How it works:** The runtime calls a universal function: `objc_msgSend(receiver, selector)`.
    1.  It checks the receiver's **Method Cache** (a hash map) for the selector name.
    2.  If missed, it searches the class's method list (linear or binary search).
    3.  If missed, it walks up the inheritance chain.
  * **Internals:** Entirely string-based (selectors). This allows you to change the mapping at runtime (**Swizzling**).
  * **Performance:** Slowest (\~15ns+), though heavily optimized by caching.
  * **Swift Usage:** Methods marked `@objc dynamic`, KVO (Key-Value Observing), and Core Data.

-----

### **4. How does Swift choose? (The Interview Matrix)**

This is the specific logic Swift uses to pick a strategy. Note the "Extension" behavior—it is a common source of bugs.

| Declared In... | Struct / Enum | Class | Protocol | Extension |
| :--- | :--- | :--- | :--- | :--- |
| **Initial Definition** | Static | Table (V-Table) | Table (Witness) | **Static** |
| **`@objc dynamic`** | N/A | Message | Message | Message |

#### **The Real-World Implication (The Extension Trap)**

Because extensions use **Static Dispatch**, they cannot be overridden dynamically.

```swift
class Base {}

// Extension uses STATIC dispatch
extension Base {
    func log() { print("Base") }
}

class Sub: Base {
    // This looks like an override, but it masks the original function.
    func log() { print("Sub") }
}

let instance: Base = Sub()
instance.log() 
// Output: "Base" 
// WHY: The compiler sees 'instance' is type Base. Extension methods are static.
// It hardcodes the address of Base.log() at compile time.
```


### 1\. Static Dispatch (Direct Dispatch)

**"The Compiler Knows All."**

This is the fastest form of dispatch. The decision of which function to run is made at **compile time**.

  * **How it works:** The compiler sees the function call, finds the exact memory address of the implementation, and hardcodes a `call` instruction to that address.
  * **Performance:** Extremely fast (1-2 nanoseconds). It also enables **Inlining**, where the compiler replaces the function call with the actual code of the function, reducing overhead to zero.
  * **Memory Layout:** No extra metadata is needed on the object.
  * **Swift usage:** `struct` methods, `enum` methods, `final class` methods, and methods in **extensions**.

**Example:**

```swift
struct Point {
    func draw() { print("Draw") }
}
let p = Point()
p.draw() 
// Compiler generates: call 0x1004F (Direct Address)
```

-----

### 2\. Dynamic Dispatch (Table Dispatch)

**"The Pointer Chase."**

This is the standard for Object-Oriented Programming. The decision is deferred until **runtime**.

  * **How it works:** The compiler doesn't know *which* implementation to run, so it generates code to look it up in a table.
  * **The V-Table (Classes):** Every class instance has a hidden pointer (often called `isa` or `vptr`) as its first 8 bytes. This points to a **Virtual Method Table (vtable)** shared by the class. The vtable is an array of function pointers.
    1.  Read the object's `isa` pointer.
    2.  Jump to the vtable.
    3.  Read the function pointer at a specific offset (e.g., index 2 for `draw`).
    4.  Jump to that function.
  * **The Witness Table (Protocols):** Since structs don't share inheritance, Swift uses a **Protocol Witness Table (PWT)**. When you cast a struct to a protocol (e.g., `any Drawable`), Swift wraps it in an "Existential Container" that holds the value *and* a pointer to the PWT.
  * **Performance:** Slower (\~5 nanoseconds) due to "pointer indirection" (chasing pointers prevents the CPU from pre-fetching instructions efficiently).
  * **Swift usage:** Standard `class` methods, `protocol` requirements.

**Example:**

```swift
class Shape { func draw() {} }
class Circle: Shape { override func draw() {} }

let s: Shape = Circle()
s.draw() 
// Runtime: Look up 's' -> Find VTable -> Find Index 0 -> Jump to Circle.draw
```

-----

### 3\. Message Dispatch

**"Ask, don't tell."**

This is the most dynamic and slowest form, used primarily by Objective-C and Swift's `@objc` features.

  * **How it works:** It does not use a fixed offset table. Instead, it sends a named message (a string selector) to the object.
  * **Internal Mechanism:** The runtime calls `objc_msgSend(object, selector)`.
    1.  It checks the object's **Method Cache** (a hash map) for the selector name.
    2.  If missed, it traverses the class's method list.
    3.  If missed, it walks up the superclass chain.
  * **Power:** Because the lookup is by *name*, not fixed offset, you can modify the lookup at runtime (Swizzling, KVO, ISA-swizzling).
  * **Performance:** Slowest (\~15+ nanoseconds), though heavily cached.
  * **Swift usage:** Methods marked `@objc dynamic`, Core Data, KVO.

-----

### The "Staff Engineer" Matrix: Swift Dispatch Rules

The most common interview "gotcha" in Swift is knowing *when* each dispatch is used. It depends on **Location** and **Type**.

| Declared Inside... | Struct / Enum | Class | Protocol | Extension |
| :--- | :--- | :--- | :--- | :--- |
| **Initial Definition** | Static | Table (V-Table) | Table (Witness) | **Static** |
| **`@objc dynamic`** | N/A | Message | Message | Message |

#### The Critical Pitfall: Extension Dispatch

Methods declared in a Swift **Extension** use **Static Dispatch** by default. This means they **cannot** be overridden by subclasses in the traditional polymorphic sense.

```swift
class Base {}

// Extensions use STATIC dispatch
extension Base {
    func greet() { print("Hello from Base") }
}

class Sub: Base {
    // This is NOT an override. It is a new function masking the old one.
    func greet() { print("Hello from Sub") }
}

let b: Base = Sub()
b.greet() 
// Output: "Hello from Base"
// Why? The compiler sees 'b' is a Base. The 'greet' in the extension is static.
// It hardcodes the call to Base.greet(), ignoring the subclass entirely.
```

### Summary

  * **Static:** "I know exactly where to go." (Fastest, Structs/Extensions).
  * **Dynamic (Table):** "I have a map (table) to find where to go." (Polymorphic, Classes/Protocols).
  * **Message:** "I will ask the object where to go." (Flexible, Objective-C/KVO).