### Overview: Struct vs. Class in Swift

The distinction between `Struct` and `Class` is the single most important architectural decision in Swift. It is not just about syntax; it is about **Value Semantics** vs. **Reference Semantics** and the resulting implications for memory management, thread safety, and performance.

| Feature | Struct | Class |
| :--- | :--- | :--- |
| **Semantics** | Value Type | Reference Type |
| **Allocation** | Stack (Mostly) | Heap (Always) |
| **Copy Behavior** | Independent Copy | Shared Pointer |
| **Mutability** | Explicit (`mutating` func) | Implicit (Reference based) |
| **Inheritance** | No (Use Protocols) | Yes (Single Inheritance) |
| **Lifecycle** | Scope-based (Automatic) | ARC (Reference Counting) |

-----

### Derived Sub-Questions

1.  **How** do they differ in Memory Allocation (Stack vs. Heap)?
2.  **What** is the difference between Pass-by-Value and Pass-by-Reference?
3.  **Why** does Identity matter (`===`)?
4.  **How** does Mutability differ internally?

-----

### 1\. Memory Allocation: Stack vs. Heap

#### **What**

  * **Stack:** A linear, highly optimized memory region. Allocation involves simply moving a pointer (stack pointer) down. Deallocation is moving it back up.
  * **Heap:** A large, unstructured memory pool. Allocation requires finding a free block of suitable size (malloc), and deallocation requires tracking usage (ARC/free).

#### **How (Structs)**

Structs are generally allocated on the **Stack**.

  * When you create a `struct Point { x, y }`, the runtime reserves space for two doubles directly in the current stack frame.
  * **Performance:** Extremely fast. Zero allocation overhead. Zero destroy overhead (popped off stack).

#### **How (Classes)**

Classes are always allocated on the **Heap**.

  * When you create `class User {}`, Swift allocates memory on the Heap for the object (plus metadata and ref counts) and stores only the **pointer** (memory address) on the Stack.
  * **Performance:** Slower. Requires memory search (malloc), thread synchronization for reference counting (retain/release), and eventual cleanup.

#### **Staff Engineer Nuance: The "Struct on Heap" Exception**

*Warning:* Structs are not *always* on the stack.

  * If a struct is captured by an escaping closure, it moves to the Heap.
  * If a struct is stored inside a Class, it lives in the Heap as part of that class's memory layout.

-----

### 2\. Pass-by-Value vs. Pass-by-Reference

#### **What**

  * **Pass-by-Value (Struct):** When assigned to a new variable or passed to a function, the **data is copied**. The new variable holds a completely independent instance.
  * **Pass-by-Reference (Class):** When assigned, only the **pointer is copied**. Both variables point to the exact same memory address.

#### **Why**

  * **Safety (Structs):** Value semantics guarantee **Local Reasoning**. You don't need to worry if some other part of your app is modifying your data behind your back.
  * **Shared State (Classes):** Reference semantics are necessary when you *need* a single source of truth (e.g., a `DatabaseConnection` or a `ViewModel` observed by multiple views).

#### **How**

```swift
// STRUCT (Value)
struct S { var data = 1 }
var a = S()
var b = a     // COPY occurs here
b.data = 2    // 'b' changes, 'a' remains 1

// CLASS (Reference)
class C { var data = 1 }
var x = C()
var y = x     // REFERENCE COPY (Pointer alias)
y.data = 2    // 'y' modifies the heap object. 'x.data' is now 2.
```

-----

### 3\. Identity (`===`)

#### **What**

  * **Classes** have **Identity**. You can distinguish between "two different objects that happen to have the same data" vs "the exact same object." You check this using the identity operator `===` (pointer comparison).
  * **Structs** have **Equality**. They do not have inherent identity. Two structs with the same properties are effectively indistinguishable. You check this using `==` (Equatability).

#### **Why**

In a distributed system or UI framework (like UIKit), identity is crucial. You need to know if the `UIView` you are touching is the exact same instance on screen. In data processing, identity is usually irrelevant—you only care if the data values are correct.

-----

### 4\. Mutability Models

#### **What**

  * **Structs:** Mutability is tied to the binding. If you declare `let s = Struct()`, you cannot modify its properties, even if they are `var`. The instance *is* the value.
  * **Classes:** Mutability is tied to the object. If you declare `let c = Class()`, you cannot change the *pointer* (make `c` point to a new object), but you **can** modify the properties inside the object.

#### **How**

```swift
struct S { var val = 0 }
let s = S()
// s.val = 1 // ❌ Error: 's' is a constant

class C { var val = 0 }
let c = C()
c.val = 1 // ✅ Valid: The pointer 'c' didn't change, the heap memory did.
```

### Summary

  * **Default to Structs** for data models (Model layer), simple states, and "dumb" data containers. They are thread-safe (by isolation), fast, and leak-proof.
  * **Use Classes** for shared state (Services, ViewModels), identity (Identifiable objects), or when you need inheritance (though composition/protocols are often better).