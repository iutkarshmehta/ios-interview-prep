32. How does `AsyncSequence` work? Give a practical example (e.g., notification stream).

This question bridges the gap between standard imperative programming (`for` loops) and reactive streams. A Junior engineer sees it as "just a loop." A Staff engineer sees it as a **Pull-Based Stream** with inherent flow control.

Here is the "Gold Standard" interview answer for Q32.

---

### **The "Staff Level" Explanation**

#### **1. The Mechanics: Pull-Based Iteration**

* **Concept:** `AsyncSequence` is the asynchronous equivalent of `Sequence`.
* Just like `Sequence` produces an `Iterator`, `AsyncSequence` produces an `AsyncIterator`.
* The key difference is the `next()` function. In a standard iterator, `next()` returns immediately. In an async iterator, `next()` is an `async` function (`func next() async throws -> Element?`).


* **Behavior:** This means the loop pauses execution at the `in` keyword waiting for the next value to arrive. This creates a **Pull-Based System**: the consumer asks for data, and the producer yields it only when requested. This naturally handles **Backpressure**â€”if the consumer is slow, the loop slows down, preventing the system from being overwhelmed by events.

#### **2. Practical Example: Notifications**

* **Scenario:** Listening for a generic "UserDidLogin" notification.
* **Old Way:** `NotificationCenter.addObserver` with a closure. We had to manage token lifecycles and worry about retain cycles.
* **AsyncSequence Way:** Apple exposes `.notifications(named:)` as an async sequence.

```swift
// The loop waits here until a notification fires
for await notification in NotificationCenter.default.notifications(named: .userDidLogin) {
    // Process notification
    await refreshUserProfile()
    
    // The loop inherently handles lifecycle. 
    // If the parent Task is cancelled, this loop terminates 
    // and the observer is automatically unregistered.
}

```

#### **3. Staff Insight: Building Custom Sequences**

* You don't just consume them; you build them using `AsyncStream`.
* `AsyncStream` bridges legacy callback-based APIs (like CoreLocation delegates) into the modern `async/await` world, handling the buffering of events so you don't miss data while the loop is processing the previous item.

---

### **The "Gold Standard" Interview Answer**

> "**`AsyncSequence`** is a protocol that allows us to iterate over a stream of values that are delivered over time, rather than all at once.
> **How it works:**
> It functions almost exactly like a standard `Sequence`, but its iterator's `next()` method is marked `async`. This allows the `for await` loop to suspend execution between elements, waiting for the network or system to produce the next value.
> **Why it's powerful (Backpressure):**
> Unlike closure-based streams (like Combine or Rx), `AsyncSequence` is a **pull-based** system. The consumer controls the speed. If my processing loop takes 5 seconds to handle an item, the stream implicitly waits before yielding the next one (or buffers it safely), preventing the 'Fast Producer, Slow Consumer' memory explosion.
> **Practical Example:**
> I use it to replace `NotificationCenter` observers.
> `for await note in NotificationCenter.default.notifications(named: .didUpdate)` allows me to process events linearly. Crucially, it respects **Structured Concurrency**: if the task running this loop is cancelled (e.g., the user leaves the screen), the iterator automatically cleans up and unregisters the observer, eliminating a whole class of memory leak bugs."

---

### **Section 11: System Design (The Next Logical Step)**

You have now mastered **ARC** and **Concurrency**. The next logical step for a Staff Engineer interview is **System Design**.

Would you like to proceed with:

1. **Mobile System Design:** "How would you design an Image Caching Library like SDWebImage from scratch?"
2. **App Architecture:** "MVVM vs Clean Architecture - handling massive ViewControllers."
3. **API Design:** "How do you design a robust Networking Layer that handles Retries, Authentication, and Caching?"
