22. **[Hot]** What is the new **Strict Concurrency Checking** in Swift 6?

This is the specific feature that turns Concurrency from a "Framework" into a "Language Guarantee."

A Junior engineer says: *"It's the setting that makes all those yellow warnings appear."*
A Staff engineer explains: *"It is the static analysis phase that guarantees—at compile time—that mutable state is never shared unprotected across isolation boundaries."*

Here is the "Gold Standard" interview answer for Q22.

---

### **The "Staff Level" Explanation**

#### **1. The Goal: Eliminating Data Races**

* **Pre-Swift 6:** You could use `async/await`, but you could still accidentally pass a mutable `class` (reference type) from the Main Thread to a Background Actor. If both touched it, you crashed. The compiler didn't stop you; it just offered tools.
* **Swift 6 Mode:** The compiler now treats **thread safety** like **type safety**. Passing a non-thread-safe object across threads is now a compile-time error, just like passing a `String` to a function expecting an `Int`.

#### **2. The Mechanism: `Sendable` Checking**

* The core of Strict Concurrency is checking the **`Sendable`** protocol boundaries.
* **The Check:** Whenever data moves from one isolation domain to another (e.g., `MainActor` -> `BackgroundActor`, or `Task` -> `Task`), the compiler asks: *"Is this data safe to send?"*
* **Yes:** It's a Value Type (struct/enum) or a frozen Actor-safe class.
* **No:** It's a standard mutable class. **Error.**



#### **3. The Migration Strategy (The Staff Concern)**

* You cannot flip a switch on a million-line codebase. Staff engineers must know the build settings:
1. **Minimal:** Only checks explicit Swift 6 features.
2. **Targeted:** Checks code that *you* have already adopted `async/await` in. (Good for incremental adoption).
3. **Complete (Strict):** Checks everything. This is the Swift 6 default.



---

### **The "Gold Standard" Interview Answer**

> "Strict Concurrency Checking is Swift's transition from **offering** concurrency tools to **enforcing** concurrency safety.
> **What it does:**
> It analyzes data flow to ensure that non-thread-safe types (types that do not conform to `Sendable`) are never passed across isolation boundaries. If I try to pass a mutable class instance into a `Task` or an `actor`, the compiler will block me because that class could be modified concurrently.
> **Why it matters:**
> Previously, data races were runtime bugs we had to hunt down with TSAN (Thread Sanitizer). Now, they are compile-time errors. It forces us to architect our data models correctly—preferring Value Types and Actors over shared mutable classes.
> **The Real Challenge (Migration):**
> The hardest part isn't understanding the concept; it's the migration. We encounter issues with **Global Mutable State** (static vars) and legacy delegates.
> * My strategy is typically to audit our 'transfer objects' first, marking simple structs as `Sendable`.
> * Then, we use `@unchecked Sendable` sparingly for legacy classes that we *know* are thread-safe (via internal locks) but the compiler can't verify."
> 
> 

---

### **Staff SE Follow-up: The "Escape Hatch"**

**Q: You mentioned `@unchecked Sendable`. When is it acceptable to use that, and when is it a 'Code Smell'?**

* **The Staff Answer:**
* **Acceptable:** When you are wrapping a C-pointer, using a legacy Objective-C class that is internally locked, or managing your own `os_unfair_lock`. You are telling the compiler: *"Trust me, I handled the synchronization manually."*
* **Code Smell:** Using it just to silence a warning because you don't want to refactor a mutable class. This defeats the entire purpose of Swift 6 and hides a potential crash.