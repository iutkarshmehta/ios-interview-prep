28. How do you handle thread safety without using Actors? (e.g., `NSLock`, `DispatchQueue` barriers).

This question tests if you understand the "Old World" mechanics that still power 90% of production apps today. A Staff Engineer must know how to mix these manual tools with modern Swift, or when to choose them *over* Actors for raw performance.

Here is the "Gold Standard" interview answer for Q28.

---

### **The "Staff Level" Explanation**

#### **1. The Reader-Writer Pattern (GCD Barriers)**

* **The Concept:** This is the most robust way to protect shared state using GCD.
* **The Problem:** Simple serial queues are safe but slow—they force reads to wait for other reads.
* **The Solution:** A **Concurrent Queue**.
* **Reads:** Perform concurrently (`queue.sync`). Multiple threads can read at the same time.
* **Writes:** Perform exclusively (`queue.async(flags: .barrier)`). The "Barrier" flag tells GCD: *"Wait for all current reads to finish, then let me run alone. Block everyone else until I'm done."*



#### **2. The Locking Approach (`NSLock` / `os_unfair_lock`)**

* **The Mechanism:** Classic Mutual Exclusion (Mutex).
* **Staff Insight:**
* **`NSLock`:** Standard, easy to use.
* **`os_unfair_lock`:** The low-level, high-performance option. It burns CPU cycles (spins) briefly before sleeping, making it faster for very short critical sections.
* **The Pattern:** You must always use `defer { lock.unlock() }` immediately after locking to ensure you don't deadlock if the function throws or returns early.



#### **3. When to use Locks over Actors?**

This is the discriminator.

* **Synchronous Requirements:** Actors are strictly `async`. If you are implementing `Equatable` or `Hashable` (which require synchronous return values) on a class that needs thread safety, **you cannot use an Actor**. You *must* use a Lock.
* **Latency:** Actors involve "hopping" and suspending. For extremely high-performance code (like audio processing or tight rendering loops), the overhead of an Actor might be too high. An `os_unfair_lock` is nanoseconds; an Actor hop can be microseconds.

---

### **The "Gold Standard" Interview Answer**

> "Before Actors, we primarily handled thread safety using the **Reader-Writer Pattern** with GCD or explicit **Locks**.
> **1. The Reader-Writer Pattern (GCD):**
> I create a `concurrent` DispatchQueue.
> * **Reads** are done synchronously (`queue.sync`). Since the queue is concurrent, multiple threads can read data simultaneously, which is high performance.
> * **Writes** are done with a **Barrier** (`queue.async(flags: .barrier)`). This ensures the write block executes exclusively—it waits for all current readers to finish, locks the queue, writes the data, and then re-opens the queue for others.
> 
> 
> **2. Explicit Locks (`NSLock` / `OSAllocatedUnfairLock`):**
> For code that must remain **synchronous** (like implementing `Equatable` or legacy delegate methods), Actors are not an option because `await` is infectious.
> In these cases, I use `OSAllocatedUnfairLock` (in Swift 6) or `NSLock`.
> * **Crucial Practice:** I always use the `defer { lock.unlock() }` pattern immediately after locking. This guarantees thread safety even if the code throws an error or has multiple return paths, preventing the most common cause of deadlocks."
> 
> 

---

### **Section 9: The "Checkmate" Question (Deadlocks)**

**Q29: What is a Deadlock? How do you debug it?**

* **Staff SE Expectation:**
* **Definition:** Thread A holds Resource 1 and waits for Resource 2. Thread B holds Resource 2 and waits for Resource 1. Neither can proceed.
* **In Swift:** Often happens with nested `dispatch_sync` calls on the same serial queue.
* **Debugging:**
1. **Xcode Pause:** Hit the pause button.
2. **Debug Navigator:** Look at the thread list.
3. **The Sign:** You will see two (or more) threads stopped at `__psynch_mutexwait` or `dispatch_barrier_sync`.
4. **TSAN:** Run with "Thread Sanitizer" enabled to catch these during testing.





**Q30: What is Priority Inversion?**

* **Staff SE Expectation:**
* **Scenario:** A High-Priority thread is waiting on a lock held by a Low-Priority thread.
* **The OS Fix:** The OS (Quality of Service) sees this and temporarily **boosts** the priority of the Low-Priority thread to match the High-Priority one, so it can finish its work and release the lock faster.
* **Relevance:** This happens automatically with GCD and Actors, but you should still avoid blocking the main thread with low-priority dependencies.



This concludes the standard **Concurrency** module.

**Where would you like to go next?**

1. **System Design for Mobile** (Offline Architecture, Image Caching, API Design)?
2. **SwiftUI Internals** (The Diffing Algorithm, Identity, Performance)?
3. **Protocol Oriented Programming** (Generics, Opaque Types, Type Erasure)?