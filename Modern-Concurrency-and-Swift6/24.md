24. How do you migrate a completion-handler based API to `async/await` using `CheckedContinuation`?

This is the "Bridge" question. It tests if you can modernize legacy code without breaking it.

A Junior engineer memorizes the syntax `withCheckedContinuation`.
A Staff engineer obsesses over the **Contract of the Continuation**—specifically, the "Resume Exactly Once" rule and what happens if that contract is violated.

Here is the "Gold Standard" interview answer for Q24.

---

### **The "Staff Level" Explanation**

#### **1. The Mechanics: Suspending the Task**

* **The Problem:** `async/await` is linear. Completion handlers are nested/callback-based.
* **The Solution:** We need to **pause** the linear execution line, go do the callback work, and then **manually resume** the line when the callback finishes.
* **The Tool:** `withCheckedContinuation` (or `withCheckedThrowingContinuation`).
* When Swift hits this line, the Task **suspends**. It gives up the thread.
* You are given a `continuation` object. This is your "remote control" to unpause the Task later.



#### **2. The Golden Rule: "Resume Exactly Once"**

This is where the interview points are scored.

* **The Contract:** You **must** call `resume()` on the continuation exactly one time.
* **Zero times:** The Task hangs forever. This is a **Task Leak**. The memory is allocated, the stack is frozen, and it never frees up.
* **Two+ times:** The app crashes. You cannot resume a task that is already running or finished.


* **Why "Checked"?**
* `CheckedContinuation` performs runtime checks. If you forget to resume (and the object deallocates), it prints a loud warning in the console. If you resume twice, it traps (crashes) with a clear error message.
* There is an `UnsafeContinuation` counterpart that skips these checks for performance (faster), but you should essentially never use it unless you are writing a high-performance library.



#### **3. Handling Cancellation (The "Expert" Detail)**

* Wrapping a completion handler does **not** automatically support cancellation.
* If the user cancels the `Task` while the legacy network request is running, the continuation is still waiting. The legacy request finishes, calls resume, and *then* the Task realizes it was cancelled.
* **Staff Fix:** You need `withTaskCancellationHandler` if you want to forward the cancellation signal to the legacy operation (e.g., calling `legacyRequest.cancel()`).

---

### **The "Gold Standard" Interview Answer**

> "To bridge a completion handler to async/await, I use the **`withCheckedThrowingContinuation`** function.
> **The Pattern:**
> I wrap the legacy call inside this function. This suspends the current Task and provides a `continuation` object. Inside the legacy completion block, I check the result. If it's a success, I call `continuation.resume(returning: value)`. If it's a failure, I call `continuation.resume(throwing: error)`.
> **The Critical Contract:**
> The most important part of this implementation is ensuring the continuation is resumed **exactly once** on all execution paths.
> * If I miss a path (e.g., a guard statement returns early without resuming), the Task will leak—it stays suspended in memory forever.
> * If I resume twice, the app crashes.
> 
> 
> **Why I use `Checked`:**
> I always prefer `CheckedContinuation` over `UnsafeContinuation` for application code. The slight performance cost is worth it because `Checked` provides runtime diagnostics—it will explicitly warn me in the console if I leak a continuation, which is invaluable for debugging complex async flows."

---
