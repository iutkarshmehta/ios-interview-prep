23. What is the difference between `Task`, `Task.detached`, and `TaskGroup`?

This question tests your understanding of **Context Inheritance** (Task Structure). A junior engineer treats `Task { }` as "just a way to run code asynchronously." A Staff engineer understands *what is inherited* (Priority, Actor context, Local Storage) and when to break that inheritance.

Here is the "Gold Standard" interview answer for Q23.

---

### **The "Staff Level" Explanation**

#### **1. `Task { }` (Unstructured, Inheriting)**

* **The Default Workhorse:** This creates a new top-level task that is **unstructured** (it doesn't have a parent waiting for it unless you store the handle), but it **inherits context**.
* **What it Inherits:**
1. **Priority:** If called from a `.userInteractive` context, the new task is also `.userInteractive`.
2. **Actor Context:** This is the big one. If you call `Task { }` inside a `@MainActor` view controller, the code inside the block **also runs on the Main Actor**.


* **Use Case:** Fire-and-forget UI updates or simple async calls where you want to stay on the current queue/actor.

#### **2. `Task.detached { }` (Unstructured, Non-Inheriting)**

* **The "Clean Slate":** This creates a new top-level task that **inherits nothing**.
* It does **not** inherit priority (defaults to `.medium` / `nil`).
* It does **not** inherit Actor context. Even if called from the Main Actor, it will run on a generic background thread.


* **Staff Insight:** Use this rarely.
* **Use Case:** You are in a UI function (Main Actor) and want to start a heavy compression job. If you use `Task { }`, you might accidentally block the Main Actor if your code isn't perfectly compliant. `Task.detached` guarantees you get off the actor immediately.

#### **3. `TaskGroup` (Structured Concurrency)**

* **The "Tree" Structure:** Created via `withTaskGroup`. This is **Structured Concurrency**.
* **The Contract:** The parent task cannot finish until *all* child tasks in the group have finished.
* **Why it's superior:**
* **Error Propagation:** If one child throws, the group can cancel the others automatically.
* **Cancellation:** If the parent is cancelled (e.g., user leaves the screen), the signal propagates down to all children instantly.


* **Use Case:** Fetching 5 images in parallel and combining the results.

---

### **The "Gold Standard" Interview Answer**

> "The difference lies in **Structure** and **Inheritance**.
> **`Task { ... }`** creates an unstructured task that **inherits the current context**. If I launch it from the Main Actor, it stays on the Main Actor. If I launch it with high priority, it keeps high priority. It's the default choice for most UI-triggered async work.
> **`Task.detached { ... }`** breaks that inheritance explicitly. It launches a task with a completely fresh context—no actor, standard priority. I use this specifically when I need to ensure a heavy operation (like data processing) does *not* contend for the Main Actor's time, effectively forcing it to a background pool.
> **`TaskGroup`** is fundamentally different because it is **Structured Concurrency**. It binds the lifecycle of child tasks to a parent scope. The function `withTaskGroup` won't return until all its child tasks are done. This provides safety guarantees—like automatic cancellation propagation and error handling—that `Task` and `Task.detached` (which are fire-and-forget) simply cannot offer."

---

### **Staff SE Follow-up: The "Priority Inversion" Trap**

**Q: You mentioned `Task` inherits priority. Why is this dangerous if I await a background task from the Main Thread?**

* **The Answer:**
* If a `.background` priority task is running, and a `.userInteractive` (Main Thread) task suddenly `awaits` the result of that background task, the system performs **Priority Escalation**.
* The background task is temporarily promoted to `.userInteractive` to unblock the UI.
* *However*, if you use `Task.detached` with a fixed low priority, you might prevent this escalation, causing the UI to hang while waiting for a low-priority job that the system doesn't know it needs to rush.



Would you like to continue with **Q24: What is the `MainActor`?** or switch to **System Design** questions?