25. What is **Structured Concurrency**? What happens to child tasks if a parent task is cancelled?

This is the philosophical core of modern Swift. A Junior engineer talks about "running things in parallel." A Staff engineer talks about **lifetimes**, **resource management**, and **local reasoning**.

Here is the "Gold Standard" interview answer for Q25.

---

### **The "Staff Level" Explanation**

#### **1. The Concept: "Concurrency that looks like the Stack"**

* **The Analogy:** In synchronous programming, if Function A calls Function B, Function A remains on the stack until B finishes. B cannot outlive A.
* **Structured Concurrency:** Swift enforces this same discipline for async tasks.
* When you create child tasks (via `async let` or `TaskGroup`), they are bound to the scope in which they were created.
* **The Guarantee:** The parent block **cannot exit** until all its child tasks have completed (either successfully or by throwing).
* **The Benefit:** This eliminates "Zombie Tasks"â€”background threads running silently long after the view controller that spawned them has been dismissed.



#### **2. Cancellation: The "Domino Effect"**

* **Propagation:** Cancellation flows **downwards**.
* If the Parent Task is cancelled (e.g., user taps "Cancel" or navigates back), the system automatically signals cancellation to all active Child Tasks.
* If a Child Task uses `TaskGroup` to spawn *grandchildren*, the signal flows to them too.


* **Error Handling:** If one child throws an error in a `TaskGroup`, the group sees failure. The group typically cancels all other running siblings immediately to save resources, then rethrows the error to the parent.

#### **3. The Critical Detail: "Cooperative Cancellation"**

This is the discriminator.

* **The Myth:** "Cancelling a task stops it immediately."
* **The Reality:** Cancellation just sets a boolean flag (`isCancelled = true`) on the task. The task continues running until it decides to check that flag.
* **Staff Insight:** If you have a tight loop processing a large file, and you don't check `Task.checkCancellation()`, the task will run to completion even if the user cancelled it 10 seconds ago. **You must write code to cooperate.**

---

### **The "Gold Standard" Interview Answer**

> "**Structured Concurrency** is a paradigm where the lifetime of asynchronous tasks is tied to the scope in which they are declared, similar to how local variables live on the stack.
> **What it solves:**
> It prevents 'Zombie Tasks.' In the old Dispatch/completion world, it was easy to fire a network request and forget to cancel it when the user left the screen. With Structured Concurrency (`async let` or `TaskGroup`), the compiler guarantees that the parent scope *cannot return* until all child tasks finish.
> **Cancellation Behavior:**
> Cancellation propagates automatically down the tree. If a parent is cancelled, all children are marked as cancelled.
> **However, the critical nuance is that cancellation is Cooperative.**
> The system does not kill the thread. It simply marks the metadata. It is up to my implementation inside the child tasks to explicitly check `Task.isCancelled` or call `Task.checkCancellation()` at appropriate checkpoints (like before starting a heavy image processing step) to respect that signal and exit early."

---

### **Section 6: Advanced Async Patterns**

**Q26: What is `AsyncStream` and when would you use it over a simple `async` function?**

* **Staff SE Expectation:**
* **Use Case:** `async` functions return **one** value. `AsyncStream` is for **multiple** values over time (like a Delegate pattern, WebSockets, or GPS updates).
* **Mechanics:** It acts as a bridge. You can push values into the stream from a non-async context (like a legacy closure), and consume them with a `for await` loop.
* **Buffering:** You must mention buffering. If the producer is faster than the consumer, `AsyncStream` handles the buffer (dropping oldest, keeping newest, or unbounded) to prevent memory explosions.



**Q27: How does `MainActor` work under the hood? Is it just the main queue?**

* **Staff SE Expectation:**
* **Answer:** Yes, it is backed by the Main Queue (GCD), but it provides compile-time safety.
* **The Difference:** `DispatchQueue.main.async` pushes work to the next run loop cycle. `@MainActor` functions can sometimes execute **synchronously** if the caller is already on the Main Actor, avoiding context switch overhead. This is a subtle optimization called "Executor hopping optimization."



Would you like to deep dive into **`AsyncStream` (Q26)** next?