### Overview: Type-Level Modifiers in Swift

In Swift, both `static` and `class` are used to define type-level members (properties and methods) rather than instance-level members. While they appear similar, the distinction lies fundamentally in **inheritance capabilities** and **storage mechanisms**.

-----

### Derived Sub-Questions

1.  **What** is the semantic difference between `static` and `class`?
2.  **Why** do we need two separate keywords?
3.  **How** do they differ in Inheritance and Overriding?
4.  **How** do they differ in Storage (Stored vs. Computed)?
5.  **How** does the compiler implement them (Dispatch & Internals)?

-----

### 1\. Semantic Difference

#### **What**

  * **`static`**: Defines a type member that is **final**. It is attached to the type itself and cannot be changed by subclasses. It is available for `struct`, `enum`, and `class`.
  * **`class`**: Defines a type member that is **open** (virtual). It is attached to the class but allows subclasses to provide their own implementation. It is available **only** for `class` types.

#### **Why**

Swift adheres to strict type safety and performance optimization rules.

  * We use `static` when we want **universal consistency** (e.g., `Double.pi` should never change).
  * We use `class` when we need **polymorphic behavior** at the type level (e.g., a Factory pattern where subclasses return different instances).

#### **How**

```swift
struct MyStruct {
    static func perform() {} // ✅ Valid
    // class func perform() {} // ❌ Error: Structs don't support inheritance
}

class MyClass {
    static func strictAction() {}  // ✅ Valid: Final
    class func openAction() {}     // ✅ Valid: Overridable
}
```

-----

### 2\. Inheritance and Overriding

#### **What**

The core functional difference is **Overridability**.

#### **Why**

To enforce architectural boundaries. You need to prevent modification of core logic (`static`) while allowing extension of flexible logic (`class`).

#### **How**

```swift
class Base {
    static func staticMethod() { print("Base Static") }
    class func classMethod() { print("Base Class") }
}

class Sub: Base {
    // ❌ Compile Error: Cannot override 'static' method
    // override static func staticMethod() { }

    // ✅ Valid: Overriding 'class' method
    override class func classMethod() { 
        print("Sub Class") 
    }
}
```

-----

### 3\. Storage Capabilities (Stored vs. Computed)

#### **What**

Swift treats type-level storage differently based on the keyword.

  * **`static`**: Supports **Stored Properties** (variables that hold data) and Computed Properties.
  * **`class`**: Supports **Computed Properties Only**.

#### **Why**

  * **`static` properties** are global variables namespaces to the type. They are stored in the static data segment of the binary.
  * **`class` properties** cannot be stored because class metadata (the runtime object representing the class type) does not support arbitrary storage expansion for subclasses. This prevents memory layout issues in the runtime.

#### **How**

```swift
class Configuration {
    // ✅ Valid: Stored static property (Lazy & Thread-safe)
    static var apiKey = "12345"
    
    // ❌ Compile Error: Class stored properties not supported
    // class var themeColor: UIColor = .red 
    
    // ✅ Valid: Computed class property
    class var alias: String {
        return "Config"
    }
}
```

*Note: `static` stored properties are lazily initialized on first access and are thread-safe (internally using `dispatch_once`).*

-----

### 4\. Compiler Implementation (Dispatch)

#### **What**

The keyword dictates the **Method Dispatch** mechanism used by the CPU.

#### **Why**

  * **`static`** enables **Static Dispatch**. Since it cannot be overridden, the compiler hardcodes the function address. This is fast and allows inlining.
  * **`class`** forces **Dynamic (Table) Dispatch**. The compiler must look up the implementation in the class's V-Table (Virtual Method Table) at runtime to check if a subclass has overridden it.

#### **How**

  * **`static func`**: Behaves identical to `final class func`.
  * **`class func`**: Behaves like a standard `func` (virtual).

| Feature | `static` | `class` | `final class` |
| :--- | :--- | :--- | :--- |
| **Availability** | Struct, Enum, Class | Class Only | Class Only |
| **Overridable** | No | **Yes** | No |
| **Stored Properties** | **Yes** | No | No (Stored `final class var` is effectively `static`) |
| **Dispatch** | Static (Direct) | Dynamic (V-Table) | Static (Direct) |

-----

### Summary

  * Use **`static`** by default for constants, singletons, and utility helpers. It offers better performance (Static Dispatch) and supports stored properties.
  * Use **`class`** only when you specifically design a class hierarchy where subclasses need to swap out type-level logic (e.g., Factory methods or dynamic configuration).