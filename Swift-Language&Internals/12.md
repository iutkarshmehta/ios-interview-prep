### Overview: Property Wrappers

**Property Wrappers** (introduced in Swift 5.1 via SE-0258) are a language feature that adds a layer of separation between the code that manages how a property is stored and the code that defines the property.

Essentially, they allow you to "wrap" a property with custom logic that triggers every time the value is read or written. This logic is defined once in a wrapper struct and reused across the entire codebase via a simple attribute syntax (e.g., `@MyWrapper`).

-----

### Derived Sub-Questions

1.  **What** is the anatomy of a Property Wrapper?
2.  **Why** are they valuable in production code?
3.  **How** do you implement a custom `@UserDefault` wrapper?
4.  **What** is the `projectedValue` ($ syntax)?

-----

### 1\. What is the anatomy of a Property Wrapper?

#### **What**

A Property Wrapper is simply a `struct`, `class`, or `enum` annotated with `@propertyWrapper`.
It **must** implement a property named `wrappedValue`.

#### **Why**

The compiler uses this structure to synthesize the boilerplate code. When you write `@UserDefault var x: Bool`, the compiler essentially translates it into:

1.  A private storage variable: `private var _x = UserDefault(...)`
2.  A computed property `x` that reads/writes to `_x.wrappedValue`.

#### **How**

```swift
@propertyWrapper
struct TwelveOrLess {
    private var number: Int
    
    // The Compiler requires this specific property name
    var wrappedValue: Int {
        get { return number }
        set { number = min(newValue, 12) } // Validation logic
    }
    
    init() { self.number = 0 }
}
```

-----

### 2\. Implementation: Custom `@UserDefault` Wrapper

This is a classic interview question. The goal is to remove the repetitive `UserDefaults.standard.set(...)` and `object(forKey:)` boilerplate.

#### **How**

We define a generic struct that holds the `key` and the `defaultValue`.

```swift
import Foundation

@propertyWrapper
struct UserDefault<T> {
    let key: String
    let defaultValue: T
    let container: UserDefaults
    
    // Dependency Injection for testability (defaults to .standard)
    init(key: String, defaultValue: T, container: UserDefaults = .standard) {
        self.key = key
        self.defaultValue = defaultValue
        self.container = container
    }
    
    var wrappedValue: T {
        get {
            // Attempt to read and cast. Return default if nil.
            return container.object(forKey: key) as? T ?? defaultValue
        }
        set {
            // Save to UserDefaults
            container.set(newValue, forKey: key)
        }
    }
}
```

#### **Usage**

```swift
struct Settings {
    // 1. Clean, declarative usage
    @UserDefault(key: "has_seen_intro", defaultValue: false)
    var hasSeenIntro: Bool
    
    @UserDefault(key: "username", defaultValue: "Guest")
    var username: String
}

// 2. The logic runs automatically
var settings = Settings()
print(settings.hasSeenIntro) // false (default)

settings.hasSeenIntro = true // Writes to UserDefaults
print(UserDefaults.standard.bool(forKey: "has_seen_intro")) // true
```

-----

### 3\. What is `projectedValue` ($ syntax)?

#### **What**

A property wrapper can optionally provide a **projected value**. This is a secondary value that exposes the "wrapper itself" or some other utility (like a Combine Publisher or a Binding). You access it using the dollar sign (`$`).

#### **Why**

It allows the wrapper to expose "API" functionality alongside the "Value".

  * In SwiftUI, `@State` uses `projectedValue` to expose a `Binding<T>`.
  * In `@Published`, `projectedValue` exposes the `Publisher`.

#### **How (Adding it to UserDefault)**

Let's say we want to access the raw key for logging purposes.

```swift
@propertyWrapper
struct UserDefault<T> {
    // ... existing code ...
    
    // The compiler looks for this property
    var projectedValue: String {
        return key
    }
}

// Usage
struct Settings {
    @UserDefault(key: "user_theme", defaultValue: "Light")
    var theme: String
    
    func logInfo() {
        // Accessing the projected value via '$'
        print("The UserDefaults key is: \($theme)") 
    }
}
```

-----

### Summary

  * **Definition:** Types annotated with `@propertyWrapper` that encapsulate read/write logic via `wrappedValue`.
  * **Key Benefit:** Eliminates boilerplate. Transforms imperative logic (getting/setting) into declarative attributes (`@UserDefault`).
  * **Mechanics:** The compiler treats the wrapper as the storage and generates a computed property to access it.
  * **Extensibility:** Use `projectedValue` (accessed via `$`) to expose additional API surface (like Bindings or Publishers).