# Interview Question #1: Sendable vs. @unchecked Sendable

**Topic:** Modern Swift Concurrency (Swift 6)
**Difficulty:** High (Essential for 2025 Interviews)

---

## The Core Concept: "Crossing Boundaries"

In modern Swift, think of threads (or Actors/Tasks) as isolated islands.
* **`Sendable`** is a "Passport."
* If a variable has this passport, it is allowed to travel from one island (thread) to another.
* If it doesn't, the compiler stops it at the border to prevent a **Data Race** (two threads crashing into the same memory).

---

## 1. What is `Sendable`? (The "Auto-Pilot" Safety)

`Sendable` is a marker protocol that tells the compiler: **"This type is safe to share concurrently."**

Most of the time, you don't even need to type it. Swift infers it automatically for **Value Types** (Structs and Enums) if their contents are also Sendable.

**Behavior:**
The compiler statically checks the code. If you try to make a mutable class `Sendable`, the compiler will throw an error because it cannot guarantee safety.

**Example: The Safe Struct**
```swift
// ✅ Implicitly 'Sendable' because it's a struct and all properties are safe.
struct UserProfile: Sendable {
    let username: String
    var highScore: Int
}

func update(user: UserProfile) async {
    // Safe to pass 'user' into a background task because it is copied (Value Type)
    Task {
        print("Processing \(user.username)")
    }
}
````

**Example: The Unsafe Class**

```swift
// ❌ COMPILER ERROR: Mutable class properties cannot be Sendable.
// The compiler refuses to give this a "passport".
final class ScoreBoard: Sendable {
    var score: Int = 0 
}
```

-----

## 2\. What is `@unchecked Sendable`? (The "Manual Override")

Sometimes, **you** know the code is thread-safe, but the **compiler** is not smart enough to figure it out.

This typically happens when you use "old school" synchronization tools like `NSLock` or `DispatchQueue` inside a class. The compiler doesn't understand that `NSLock` protects the data; it just sees a mutable variable and panics.

`@unchecked Sendable` is you telling the compiler: **"Disable the safety checks. I have manually implemented thread safety. If it crashes, it's my fault."**

**Example: The Thread-Safe Cache**
We use `@unchecked` here because we use a private queue to ensure safety.

```swift
import Foundation

// ⚠️ We use @unchecked because the compiler doesn't know 'dispatchQueue' makes this safe.
final class ThreadSafeCache: @unchecked Sendable {
    
    // 1. Private mutable state (Dangerous to the compiler!)
    private var storage: [String: String] = [:]
    
    // 2. The Lock (The Protection)
    private let queue = DispatchQueue(label: "com.myapp.cache", attributes: .concurrent)

    // 3. Safe Write
    func set(_ value: String, forKey key: String) {
        queue.async(flags: .barrier) {
            self.storage[key] = value
        }
    }

    // 4. Safe Read
    func get(_ key: String) -> String? {
        queue.sync {
            return storage[key]
        }
    }
}
```

-----

## Summary Comparison

| Feature | `Sendable` | `@unchecked Sendable` |
| :--- | :--- | :--- |
| **Meaning** | Compiler validates thread safety. | Developer promises thread safety. |
| **Safety Level** | **High.** The compiler enforces rules. | **Low.** You can easily introduce bugs. |
| **Primary Use Case** | Structs, Enums, Actors, Immutable Classes. | Classes using `NSLock`, `DispatchQueue`, or pointers. |
| **Analogy** | Autonomous Driving (Computer controls). | Manual Transmission (You shift gears). |

-----