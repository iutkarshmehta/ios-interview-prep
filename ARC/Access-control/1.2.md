**Q2: What is the default access level in Swift if you don't specify one? Are there any exceptions?**

* **Staff SE Expectation:**
* **Answer:** `internal`.
* **The Trap:** "Are there exceptions?"
* **Exceptions:**
1. **Framework Init:** If you write a `public` struct, the implicit `init` is still `internal`. You must explicitly write `public init`. This is a classic "gotcha" when creating libraries.
2. **Protocol Extensions:** Default to the requirement's level.

---

### **The Default: `internal**`

If you do not specify an access control keyword, the entity is **`internal`**.

* **Meaning:** The code is accessible anywhere within the defining **module** (your App Target or Framework Target), but hidden from anything importing that module.
* **Design Philosophy:** Apple assumes the most common use case is "App Development" (where everything needs to talk to everything), not "Framework Development."

---

### **The "Trap" (Exceptions & Gotchas)**

A Staff Engineer knows that relying on defaults is dangerous when crossing module boundaries. Here are the critical exceptions where "default" behavior often bites developers.

#### **Exception 1: The Implicit Initializer Trap (The #1 Library Bug)**

This is the most common failure mode when splitting code into modules.

* **The Scenario:** You create a `public struct` in a framework so other modules can use it.
* **The Behavior:** Swift automatically generates a "memberwise initializer" for structs.
* **The Trap:** **The generated initializer is `internal`, not `public`.**
Even though the struct is public, consumers cannot *create* it because the `init` is hidden.
* **The Fix:** You must explicitly write a `public init`.

```swift
// In MyFramework
public struct User {
    public let name: String
    
    // ❌ WRONG: If you omit this, the default init is 'internal'.
    // The main app cannot create a User().
    
    // ✅ RIGHT: You must explicitly expose the init.
    public init(name: String) {
        self.name = name
    }
}

```

#### **Exception 2: Protocol Requirements**

Protocols don't follow the standard inheritance of access control in the same way classes do.

* **The Rule:** If you define a `public` protocol, the requirements inside it (functions/vars) are **automatically `public**`. You cannot mark a function inside a `public` protocol as `internal`.
* **Why?** A protocol defines a contract. It makes no sense to have a "public contract" with "secret terms." If the protocol is visible, all its requirements must be visible so conformers can implement them.

#### **Exception 3: Private Types in Public APIs (The Compiler Guardrail)**

Swift enforces a "Access Level Hierarchy" to prevent logical paradoxes.

* **The Rule:** A function cannot have a higher access level than its parameters or return type.
* **The Trap:** You cannot have a `public` function that returns an `internal` or `private` type.
* **Staff Insight:** The compiler prevents this because the consumer would receive an object they are not allowed to know about.

```swift
private struct SecretData {}

// ❌ Compile Error: Method must be 'private' or 'fileprivate'
// because its return type is private.
public func getSecret() -> SecretData {
    return SecretData()
}

```

#### **Exception 4: Extension Defaults**

When you add an extension to a type, the default access level inside the extension depends on the extension's modifier.

* **Standard Extension:** `extension User { ... }`
* Members default to **`internal`**.


* **Private Extension:** `private extension User { ... }`
* Members default to **`fileprivate`** (Swift 4+ change).
* *Nuance:* This is because `private` on a top-level extension essentially limits the scope to the file, so the members become `fileprivate`.



---

### **The "Why This Matters" Summary**

> "The takeaway is that **Access Control is about the Consumer Contract**.
> While `internal` is the convenient default for App Development, it is catastrophic for Library Development if used blindly.
> The most critical nuance is the **Implicit Initializer**. Swift forces library authors to be intentional about creation. Just because a type is public doesn't mean I want you to be able to *create* it (e.g., a token that only my library should vend). By default, Swift protects the creation logic, forcing us to opt-in with a `public init`."