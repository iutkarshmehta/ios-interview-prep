### Overview: Extensions

**Extensions** add new functionality to an existing class, structure, enumeration, or protocol type. Crucially, they allow you to extend types **for which you do not have the original source code** (Retroactive Modeling).

However, they are not just syntactic sugar; they are a fundamental tool for code organization (Protocol-Oriented Programming) and usually have distinct compilation and memory characteristics compared to the original type definition.

-----

### Derived Sub-Questions

1.  **What** are the capabilities and limitations of Extensions?
2.  **Why** can’t you add Stored Properties? (The Memory Layout Problem)
3.  **How** can you simulate stored properties? (Associated Objects)
4.  **How** does Extension Dispatch differ from the main body?

-----

### 1\. Capabilities and Limitations

#### **What**

Extensions can:

  * Add **Computed** instance/type properties.
  * Define instance/type methods.
  * Provide new initializers (convenience only for classes).
  * Define subscripts.
  * Define and use new nested types.
  * Make an existing type conform to a protocol.

Extensions **cannot**:

  * Add **Stored** properties (variables that occupy memory).
  * Add `required` initializers (usually).
  * Override existing methods (the compiler blocks this to prevent ambiguity and fragility).

-----

### 2\. Why can’t you add Stored Properties? (The Memory Layout Problem)

#### **The Core Restriction**

You absolutely **cannot** add a stored property (e.g., `var id: String`) in an extension.

```swift
extension UIView {
    var id: String = "123" // ❌ Compiler Error: Extensions must not contain stored properties
}
```

#### **Why (Low-Level Explanation)**

This is a **Memory Layout** constraint.

1.  **Fixed Size:** When the Swift compiler builds the original type (e.g., `struct User`), it calculates the exact memory size and the memory offset of every property (e.g., `name` is at offset 0, `age` is at offset 8).
2.  **Binary Compatibility:** This layout is baked into the compiled binary.
3.  **The Conflict:** If Extensions could add storage, loading a generic library (like a 3rd party Framework) that extends `Int` or `UIView` would change the memory size of that type.
      * If Module A thinks `User` is 16 bytes, and Module B (via extension) thinks `User` is 24 bytes, passing a `User` from A to B would cause memory corruption (buffer overflows).
      * Since extensions can be loaded dynamically at runtime, the compiler cannot guarantee a stable memory layout if extensions could expand the size of a type.

-----

### 3\. How to simulate Stored Properties? (Associated Objects)

#### **What**

If you *really* need to attach data to an object in an extension (common in framework development), you can use the Objective-C Runtime feature called **Associated Objects**.

*Note: This only works for **Classes** (Reference Types), not Structs.*

#### **How**

You use `objc_getAssociatedObject` and `objc_setAssociatedObject` to store a value in a side-table managed by the runtime, using the object's memory address as a key.

```swift
import ObjectiveC

// 1. Create a unique key (address of this static var)
private var associatedKey: UInt8 = 0

extension UIView {
    var customTag: String? {
        get {
            // Read from the runtime side-table
            return objc_getAssociatedObject(self, &associatedKey) as? String
        }
        set {
            // Write to the runtime side-table
            objc_setAssociatedObject(
                self, 
                &associatedKey, 
                newValue, 
                .OBJC_ASSOCIATION_RETAIN_NONATOMIC
            )
        }
    }
}
```

#### **Performance Cost**

This is significantly slower than a real stored property. It involves a global hash table lookup and locking mechanisms inside the Obj-C runtime. Use it sparingly.

-----

### 4\. Extension Dispatch (Static vs. Dynamic)

#### **What**

As discussed in previous topics, methods declared in extensions behave differently regarding polymorphism.

#### **Why**

Because extensions can be defined in separate modules, they are not typically added to the class's **Virtual Method Table (vtable)**. Recompiling the vtable for every extension would be inefficient and complex.

#### **How**

  * **Standard Extension:** Uses **Static Dispatch**. Subclasses cannot override these methods.
    ```swift
    extension MyClass {
        func doWork() { ... } // Static Dispatch. Subclass override ignored.
    }
    ```
  * **`@objc` Extension:** Uses **Message Dispatch**. Subclasses *can* override these if they also use dynamic dispatch, but it's risky and often discouraged by the Swift compiler due to "non-modular header" issues.

### Summary

  * **Purpose:** Horizontal scaling of functionality and Protocol conformance.
  * **Stored Properties:** **Forbidden** because they would alter the fixed memory layout of the type, breaking binary compatibility.
  * **Workaround:** Use **Associated Objects** (Obj-C Runtime) for Classes to "fake" storage, but beware of performance costs.
  * **Dispatch:** Defaults to **Static Dispatch** (Direct call), meaning extension methods are not overridable by default.