### Overview: `Sequence` vs. `Collection`

In Swift, these two protocols form the backbone of data structure iteration. The fundamental distinction lies in **Traversal Guarantees** and **Access Capability**.

  * **`Sequence`**: Represents a list of values that can be stepped through **once**. It guarantees iteration, but not repeatability or indexed access.
  * **`Collection`**: Inherits from `Sequence`. It represents a stable list of values that can be traversed **multiple times** non-destructively and accessed via **Indices**.

-----

### Derived Sub-Questions

1.  **What** is a `Sequence` (The Single-Pass Rule)?
2.  **What** is a `Collection` (The Multi-Pass & Index Rule)?
3.  **Why** does this distinction matter for API Design & Performance?
4.  **How** do you choose between them?

-----

### 1\. What is a `Sequence`?

#### **What**

`Sequence` is the minimal requirements protocol. It only requires that a type provide an `Iterator` (`makeIterator()`).

#### **The "Destructive" Trap**

A `Sequence` makes **no guarantee** that you can iterate over it more than once.

  * **Example:** A standard input stream (`stdin`) or a network socket stream. Once you read a byte, it is consumed.
  * **Behavior:** If you try to loop over a `Sequence` a second time, it is allowed to return `nil` immediately or crash.

<!-- end list -->

```swift
struct Countdown: Sequence, IteratorProtocol {
    var count: Int
    mutating func next() -> Int? {
        if count == 0 { return nil }
        defer { count -= 1 }
        return count
    }
}

var s = Countdown(count: 3)
// Pass 1
for i in s { print(i) } // Prints 3, 2, 1

// Pass 2
for i in s { print(i) } // Prints NOTHING (Sequence is exhausted)
```

-----

### 2\. What is a `Collection`?

#### **What**

`Collection` inherits from `Sequence` and adds strict requirements:

1.  **Multi-Pass:** Iterating effectively creates a generic cursor; it does not consume the collection. You can iterate thousands of times safely.
2.  **Indexed Access:** It must define a `startIndex`, `endIndex`, and a `subscript` to access elements directly.
3.  **Finite Count:** It is expected to be finite (unlike sequences, which can be infinite).

#### **Internal Mechanics**

A Collection doesn't just give you the "next" element; it gives you a map of positions (Indices).

  * **Types:** `Array` (Integer indices), `Dictionary` (Hash-based indices), `String` (CharacterView indices).

-----

### 3\. Why does this matter? (Performance & Correctness)

#### **A. The `count` Performance Trap**

  * **Sequence:** Since it's just a stream, finding the `count` usually requires traversing the entire sequence. **Complexity: $O(n)$**.
  * **Collection:** Usually knows its bounds. `RandomAccessCollection` (like Array) guarantees `count` is **$O(1)$**.

#### **B. API Safety**

If you write a generic function that accepts `Sequence`, you cannot access element `[0]`. You also cannot assume the data persists after your function runs.

```swift
// ❌ Dangerous: Might drain a stream
func check(data: some Sequence) {
    let count = data.reduce(0) { $0 + 1 } // Traversal 1 (O(n))
    print(count)
    
    for x in data { print(x) } // Traversal 2 (Might be empty!)
}

// ✅ Safe: Guaranteed stable
func check(data: some Collection) {
    print(data.count) // Often O(1)
    for x in data { print(x) } // Guaranteed to work
}
```

-----

### Summary Table

| Feature | Sequence | Collection |
| :--- | :--- | :--- |
| **Inheritance** | Base Protocol | Inherits `Sequence` |
| **Traversal** | Single-Pass (potentially destructive) | Multi-Pass (non-destructive) |
| **Access** | Iteration only (`next()`) | Indexed Subscript (`data[i]`) |
| **Count Cost** | $O(n)$ (Must walk to count) | Usually $O(1)$ (property) |
| **Infinite?** | Allowed (e.g., `sequence(first:next:)`) | No (Must have `endIndex`) |
| **Use Case** | Data Streams, Generators | Arrays, Sets, Dictionaries, UI Data |

**Staff Engineer Tip:**
In your function signatures, default to `Collection`. Only use `Sequence` if you specifically intend to support one-off generators or infinite streams. Using `Sequence` for static data limits your ability to optimize (no random access).