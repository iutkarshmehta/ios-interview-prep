### Overview: Access Control

Access Control is the primary tool for **Module Stability** and **Encapsulation** in Swift. It restricts which parts of your code can be accessed or modified by other parts, enforcing clear API boundaries.

Swift uses a **file-based** and **module-based** hierarchy, which differs from the class-based or package-based systems seen in Java or C++.

-----

### Derived Sub-Questions

1.  **What** is the hierarchy of access levels?
2.  **Why** and **When** do you use `open` vs. `public`?
3.  **What** is the distinction between `private` and `fileprivate`?
4.  **How** does `internal` behave as the default?

-----

### 1\. The Hierarchy (Least to Most Restrictive)

| Level | Scope | Cross-Module? | Subclassable? |
| :--- | :--- | :--- | :--- |
| **`open`** | Universal | ✅ Yes | ✅ Yes (Outside module) |
| **`public`** | Universal | ✅ Yes | ❌ No (Only inside module) |
| **`internal`** | Module-wide | ❌ No | ✅ Yes (Inside module) |
| **`fileprivate`** | File-wide | ❌ No | ✅ Yes (Inside file) |
| **`private`** | Scope-wide | ❌ No | ❌ No |

-----

### 2\. `open` vs. `public`

This is the most critical distinction for Framework/Library developers.

#### **What**

  * **`public`**: The class/method is visible to other modules (targets), but it **cannot be subclassed or overridden** by them. It is "final" to the outside world.
  * **`open`**: The class/method is visible **and** can be subclassed or overridden by external modules.

#### **Why**

This distinction protects **API Stability**.
If you mark a class as `public`, you are promising clients they can *use* it. If you mark it `open`, you are promising clients they can *change its behavior* (subclassing).
Designing a class for inheritance is much harder than designing it for usage. `open` forces you to consciously opt-in to that complexity.

#### **How (Framework Example)**

```swift
// In 'MyUIKit' Framework

// Clients can instantiate generic views, but cannot subclass them
public class BaseView {
    public func render() {}
}

// Clients are EXPECTED to subclass this (e.g., UIViewController)
open class ScreenController {
    open func viewDidLoad() {} // Intended for override
}
```

-----

### 3\. `private` vs. `fileprivate`

#### **What**

  * **`private`**: Visible only within the enclosing declaration (the `{}` block) and extensions of that type *in the same file*.
  * **`fileprivate`**: Visible anywhere within the current `.swift` source file.

#### **Why**

  * Use **`private`** by default for strict encapsulation of implementation details.
  * Use **`fileprivate`** when you have a type and an `extension` in the same file that need to share "secret" data, or multiple classes in one file that interact closely.

#### **How**

```swift
class A {
    private var secret = 1
    fileprivate var sharedSecret = 2
}

extension A {
    func access() {
        print(secret) // ✅ Swift 4+ allows private access in extensions in same file
    }
}

class B { // Another class in the same file
    func test(a: A) {
        // print(a.secret) // ❌ Error: 'secret' is private to A
        print(a.sharedSecret) // ✅ Valid: B is in the same file
    }
}
```

-----

### 4\. `internal` (The Default)

#### **What**

If you write no keyword, the entity is `internal`. It is visible everywhere inside your **App** or **Framework**, but hidden from outside.

#### **Why**

This allows you to write code freely across your project without cluttering your public interface. It assumes that if code is in the same module (compiled together), it is "trusted."

### Summary

  * **`open`**: "I want external developers to subclass this." (Frameworks only).
  * **`public`**: "I want external developers to use this, but not change behavior."
  * **`internal`**: "Visible to my team/module only." (Default).
  * **`fileprivate`**: "Visible to everything in this file."
  * **`private`**: "Visible only to this specific scope/class."

**Staff Engineer Tip:**
Always start with `private`. Only promote to `internal` or `public` when absolutely necessary. This "Lockdown by Default" strategy minimizes your API surface area and makes refactoring significantly safer.