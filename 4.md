
# Interview Question #4: weak vs. unowned References

**Topic:** Memory Management (ARC)
**Difficulty:** Core Concept

---

## 1. The High-Level Difference

Both `weak` and `unowned` allow you to reference an object **without** increasing its reference count (avoiding a Retain Cycle). The difference lies in what happens when the object they point to is deallocated (freed from memory).

* **`weak` is safe.** If the object dies, the pointer becomes `nil`.
* **`unowned` is strict.** If the object dies, the pointer keeps pointing to the old memory address (a "dangling pointer"). If you touch it, the app crashes.

---

## 2. Comparison Table

| Feature | `weak` | `unowned` |
| :--- | :--- | :--- |
| **Type Requirement** | Must be **Optional** (`Optional<T>` / `T?`). | Can be **Non-Optional** (`T`). |
| **Mutability** | Must be a `var` (because it can change to nil). | Can be a `let` (if set once and never changed). |
| **Object Deallocation** | Automatically sets the reference to `nil`. | **CRASHES** if accessed after the object is gone. |
| **Performance** | Slight overhead (ARC tracks it in a "side table"). | Faster (direct memory access, no nil check). |

---

## 3. When is `unowned` safe to use?

You use `unowned` when there is a strict **Owner-Owned** relationship where **the child cannot exist without the parent**.

**The Golden Rule:**
> "Use `unowned` ONLY if you are 100% sure the referenced object has a **longer lifecycle** (or the same lifecycle) than the object holding the reference."

### âœ… Example: The "Credit Card" Scenario (Safe use of `unowned`)
A Credit Card *must* have a Bank Account. It makes no sense for a card to exist without an account.

```swift
class BankAccount {
    var card: CreditCard?
    
    init() {
        // The Account creates the Card. The Account "owns" the Card.
        self.card = CreditCard(account: self)
    }
}

class CreditCard {
    // 1. We use 'unowned' because a Card CANNOT exist without an Account.
    // 2. We use 'let' because the account never changes.
    // 3. We don't need to unwrap it (?) every time we use it.
    unowned let account: BankAccount
    
    init(account: BankAccount) {
        self.account = account
    }
    
    func printOwner() {
        // No need for 'guard let' or optional binding!
        print("This card belongs to account ID: \(account.id)")
    }
}
````

*Why is this safe?*
Because the `BankAccount` holds the `CreditCard` strongly. The `CreditCard` will be deallocated *before* (or at the same time as) the `BankAccount`. It is impossible to access `account` after the bank account is dead, because the card would be dead too.

-----

### âš ï¸ Example: The "Delegate" Scenario (Use `weak` here\!)

A generic delegate (like a TableView delegate) is **not** guaranteed to outlive the object. The screen might be dismissed while a network request is finishing.

```swift
protocol DataDelegate: AnyObject {
    func didFinishData()
}

class DataFetcher {
    // âŒ DANGEROUS: If the ViewController is dismissed, this crashes!
    // unowned var delegate: DataDelegate
    
    // âœ… CORRECT: The delegate might become nil. Handle it gracefully.
    weak var delegate: DataDelegate?
    
    func finish() {
        delegate?.didFinishData()
    }
}
```

-----

## ðŸ’¡ Interview Pro-Tip

This is the "Senior Engineer" answer:

> "In the early days of Swift, we used `unowned` frequently in closures (e.g., `[unowned self]`) to avoid optional unwrapping.
>
> However, in modern Swift (2025), the best practice is to **almost always default to `weak`**. The tiny performance gain of `unowned` is rarely worth the risk of a crash if the object graph changes unexpectedly. I only use `unowned` if the relationship is architecturally rigid, like a View holding its ViewModel where the View is guaranteed to die first."
